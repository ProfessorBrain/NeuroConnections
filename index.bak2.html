<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ðŸ§  NeuroConnections</title>
<style>
  :root{
    --bg:#f8fafc; --text:#0f172a; --muted:#64748b; --card:#ffffff; --border:#d1d5db;
    --tile:#ffffff; --tile-hover:#f8fafc; --tile-selected:#e0e7ff; --tile-selected-border:#a5b4fc;
    --ok:#16a34a; --warn:#d97706; --err:#dc2626;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0; background:var(--bg); color:var(--text); font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Helvetica,Arial,sans-serif; line-height:1.25;}
  .wrap{width:min(520px,92vw); margin:0 auto; padding:40px 0 24px; position:relative;}
  h1{margin:0 0 6px; text-align:center; font-weight:900; font-size:28px; letter-spacing:-0.01em}
  h2{margin:0; text-align:center; font-weight:700; font-size:18px}
  .date-bar{ margin-top:6px; text-align:center; color:var(--muted); font-size:12px; user-select:none }
  .grid{margin-top:24px; display:grid; grid-template-columns:repeat(4,1fr); gap:10px; justify-items:center;}
  .tile{
    width:120px; min-height:88px; max-height:160px;
    border-radius:10px; border:1px solid var(--border); background:var(--tile);
    display:flex; align-items:center; justify-content:center;
    font-weight:800; font-size:18px; text-align:center; cursor:pointer;
    transition:background .15s ease, border-color .15s ease, transform .02s ease-in-out;
    user-select:none; padding:10px; line-height:1.15;
    word-break:break-word; hyphens:auto; overflow:hidden;
  }
  .tile:hover{ background:var(--tile-hover); }
  .tile.selected{ background:var(--tile-selected); border-color:var(--tile-selected-border); outline:2px solid var(--tile-selected-border); }
  .solved-card{ grid-column:1/-1; width:100%;
    border-radius:10px; border:1px solid var(--border); background:var(--card);
    padding:12px; display:flex; align-items:center; gap:10px; }
  .badge{ font-weight:900; padding:6px 10px; border-radius:999px; color:#0b0e12; font-size:12px; }
  .toast{
    position:absolute; left:50%; transform:translateX(-50%);
    top:64px; z-index:20; pointer-events:none;
    font-weight:700; font-size:14px; border-radius:8px; padding:8px 10px; display:none; border:1px solid transparent;
  }
  .toast.show{display:block}
  .toast.ok{ background:rgba(22,163,74,.10); border-color:rgba(22,163,74,.35)}
  .toast.warn{ background:rgba(217,119,6,.10); border-color:rgba(217,119,6,.35)}
  .toast.err{ background:rgba(220,38,38,.10); border-color:rgba(220,38,38,.35)}
  .controls{ margin-top:18px; display:flex; align-items:center; justify-content:center; gap:10px; flex-wrap:wrap;}
  .btn{ border-radius:10px; border:1px solid var(--border); background:#fff; color:#0f172a; padding:14px 20px; font-weight:900; letter-spacing:.06em; text-transform:uppercase; font-size:13px; cursor:pointer; }
  .btn:hover{ background:#f8fafc; }
  footer{ margin-top:14px; text-align:center; color:#94a3b8; font-size:12px; user-select:none}
  .skeleton{ width:120px; height:120px; border-radius:10px; border:1px solid var(--border); background:linear-gradient(90deg, #ffffff 25%, #f1f5f9 37%, #ffffff 63%); background-size:400% 100%; animation:shimmer 1.2s infinite; }
  @keyframes shimmer{ 0%{background-position:100% 0} 100%{background-position:0 0} }
  .loader{ margin-top:10px; text-align:center; color:var(--muted); font-size:14px; white-space:pre-wrap; }
  .uploader{ display:none; margin-top:10px; text-align:center; }
  .uploader.show{ display:block; }
</style>
</head>
<body>
  <div class="wrap">
    <h1><span aria-hidden="true">ðŸ§ </span> NeuroConnections</h1>
    <h2>Create four groups of four!</h2>
    <div id="puzzleDate" class="date-bar"></div>

    <div id="toast" class="toast" role="status" aria-live="polite"></div>

    <div id="grid" class="grid" aria-label="Tiles grid"></div>
    <div id="loader" class="loader"></div>

    <div id="uploader" class="uploader">
      <input id="fileInput" type="file" accept=".csv,text/csv" />
      <div style="margin-top:8px; color:#64748b; font-size:12px">Tip: Use this when opening the file directly (file://) where browsers block fetching local CSVs.</div>
    </div>

    <div class="controls">
      <button id="shuffle" class="btn" type="button">Shuffle</button>
      <button id="hint" class="btn" type="button">Hint</button>
      <button id="deselect" class="btn" type="button">Deselect All</button>
      <button id="submit" class="btn" type="button">Submit</button>
    </div>

    <footer>created by micah etter, md and sean lee, md</footer>
  </div>

  <script>
  // ================= Utilities =================
  const DIFFICULTY_COLORS = { yellow:'#F2C14E', green:'#5DD0C2', blue:'#6AA6FF', purple:'#B388EB' };
  const FALLBACK_COLORS = ['#B388EB','#5DD0C2','#F2C14E','#F78C6C'];

  const gridEl = document.getElementById('grid');
  const submitEl = document.getElementById('submit');
  const deselectEl = document.getElementById('deselect');
  const shuffleEl = document.getElementById('shuffle');
  const hintEl = document.getElementById('hint');
  const loaderEl = document.getElementById('loader');
  const uploaderEl = document.getElementById('uploader');
  const fileInput = document.getElementById('fileInput');
  const toastEl = document.getElementById('toast');
  const dateEl = document.getElementById('puzzleDate');

  let dayOffset = 0; // secret 'N'

  // skeleton now to avoid white screen
  (function renderSkeleton(){
    gridEl.innerHTML = '';
    const frag = document.createDocumentFragment();
    for(let i=0;i<16;i++){ const d=document.createElement('div'); d.className='skeleton'; frag.appendChild(d); }
    gridEl.appendChild(frag);
    loaderEl.textContent = 'Loading puzzles.csvâ€¦';
  })();

  function phoenixISODateFromOffset(offset){
    const msPerDay = 86400000;
    const target = new Date(Date.now() + offset*msPerDay);
    const fmt=new Intl.DateTimeFormat('en-CA',{timeZone:'America/Phoenix',year:'numeric',month:'2-digit',day:'2-digit'});
    const p=fmt.formatToParts(target);
    return `${p.find(x=>x.type==='year').value}-${p.find(x=>x.type==='month').value}-${p.find(x=>x.type==='day').value}`;
  }
  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]];} return a; }
  function rgba(hex,alpha=.15){ const s=hex.replace('#',''); const x=s.length===3? s.split('').map(c=>c+c).join(''):s; const n=parseInt(x,16); const r=(n>>16)&255,g=(n>>8)&255,b=n&255; return `rgba(${r},${g},${b},${alpha})`; }
  function showToast(msg,kind){ toastEl.textContent = msg; toastEl.className = 'toast show '+(kind||''); if(kind!=='err'){ clearTimeout(showToast._t); showToast._t=setTimeout(()=>{ toastEl.className='toast'; },1500);} }

  // Robust CSV parser (RFC4180-ish)
  function parseCSV(text){
    const rows = []; let cur = [], val = '', i = 0, inQuotes = false;
    const pushVal = ()=>{ cur.push(val); val=''; };
    const pushRow = ()=>{ rows.push(cur); cur=[]; };
    while(i < text.length){
      const ch = text[i];
      if(inQuotes){
        if(ch === '"'){ if(text[i+1] === '"'){ val += '"'; i+=2; } else { inQuotes = false; i++; } }
        else { val += ch; i++; }
      }else{
        if(ch === '"'){ inQuotes = true; i++; }
        else if(ch === ','){ pushVal(); i++; }
        else if(ch === '\r'){ i++; }
        else if(ch === '\n'){ pushVal(); pushRow(); i++; }
        else { val += ch; i++; }
      }
    }
    pushVal(); if(cur.length>1 || (cur.length===1 && cur[0]!=='')) pushRow();
    if(rows.length === 0) return [];
    const headers = rows[0].map(h => (h||'').trim().toLowerCase());
    return rows.slice(1).map(cols => { const obj = {}; headers.forEach((h, idx)=> obj[h] = (cols[idx]||'').trim()); return obj; });
  }

  function pickDifficultyColor(val, idx){
    if(!val) return FALLBACK_COLORS[idx % FALLBACK_COLORS.length];
    const key = String(val).toLowerCase();
    if (DIFFICULTY_COLORS[key]) return DIFFICULTY_COLORS[key];
    if(/^#([0-9a-f]{3}|[0-9a-f]{6})$/i.test(val)) return val;
    return FALLBACK_COLORS[idx % FALLBACK_COLORS.length];
  }

  function rowsToPuzzles(rows){
    // Columns: date, category, item1..item4, (optional) difficulty|tier|color
    const byDate=new Map();
    for(const r of rows){
      const date=r['date']||'';
      const category=r['category'];
      const items=[r['item1'],r['item2'],r['item3'],r['item4']].filter(Boolean);
      const difficulty = r['difficulty'] || r['tier'] || r['color'] || '';
      if(!date||!category||items.length!==4) continue;
      if(!byDate.has(date)) byDate.set(date,[]);
      byDate.get(date).push({name:category, items, difficulty});
    }
    const dates=[...byDate.keys()].sort();
    const puzzles = [];
    for(const d of dates){
      const cats = byDate.get(d);
      const valids = cats.filter(c=>c.items.length===4);
      if(valids.length < 4) continue;
      puzzles.push({
        title:d,
        categories: valids.slice(0,4).map((c,i)=> ({...c, color: pickDifficultyColor(c.difficulty, i)}))
      });
    }
    return puzzles;
  }

  // ================= Game state & rendering =================
  let PUZZLES=[], PUZZLE=null, solved=[], selected=new Set(), remaining=new Set(), order=[], itemToCat=new Map();

  // Hints
  let hintedColors = new Map(); // item -> color for visual hinting
  let hintPhase = 'idle'; // 'idle' | 'single'
  let hintGroupIdx = -1;
  let hintedItem = null;

  function clearHintState(){ hintPhase='idle'; hintGroupIdx=-1; hintedItem=null; hintedColors.clear(); }

  function chooseUnsolvedGroupIndex(){
    if(!PUZZLE) return -1;
    // choose first group fully remaining
    for(let i=0;i<PUZZLE.categories.length;i++){
      const c = PUZZLE.categories[i];
      if(c.items.every(it => remaining.has(it))) return i;
    }
    return -1;
  }

  function fitTiles(){
    const tiles = gridEl.querySelectorAll('.tile');
    tiles.forEach(tile=>{
      tile.style.fontSize = '18px';
      const maxH = parseInt(getComputedStyle(tile).maxHeight) || 160;
      let fs = 18, minFs = 12;
      while(tile.scrollHeight > maxH && fs > minFs){
        fs -= 1; tile.style.fontSize = fs + 'px';
      }
    });
  }

  function setDateBarText(dateStr, usedRotation){
    dateEl.textContent = usedRotation ? `Puzzle date: ${dateStr} (rotated match)` : `Puzzle date: ${dateStr}`;
  }

  function selectPuzzleForCurrentOffset(){
    const dateStr = phoenixISODateFromOffset(dayOffset);
    let idx = PUZZLES.findIndex(p=>p.title===dateStr);
    let rotated = false;
    if(idx < 0){
      const baseDay = Math.floor(Date.now()/86400000);
      idx = (baseDay + dayOffset) % PUZZLES.length;
      if(idx < 0) idx += PUZZLES.length;
      rotated = true;
    }
    setDateBarText(dateStr, rotated);
    return PUZZLES[idx];
  }

  function initBoard(){
    solved=[]; selected.clear(); clearHintState();
    remaining = new Set(PUZZLE.categories.flatMap(c=>c.items));
    order = shuffle([...remaining]);
    itemToCat = new Map();
    PUZZLE.categories.forEach((c, idx)=> c.items.forEach(it=> itemToCat.set(it, idx)));
    loaderEl.textContent='';
    render();
  }

  function getUnsolvedOrder(){ return order.filter(it=>remaining.has(it)); }

  function render(){
    const frag = document.createDocumentFragment();
    gridEl.innerHTML='';

    // solved cards
    for(const g of solved){
      const card=document.createElement('div'); card.className='solved-card'; card.style.background=rgba(g.color,.15); card.style.borderColor=g.color;
      const badge=document.createElement('span'); badge.className='badge'; badge.style.background=g.color; badge.textContent=g.name;
      const items=document.createElement('div'); items.style.opacity='.95'; items.style.fontWeight='700'; items.textContent=g.items.join(' â€¢ ');
      card.appendChild(badge); card.appendChild(items); frag.appendChild(card);
    }

    // remaining tiles
    for(const it of getUnsolvedOrder()){
      const b=document.createElement('button'); b.type='button'; b.className='tile'; b.textContent=it;
      const isSel=selected.has(it); if(isSel) b.classList.add('selected');
      b.setAttribute('aria-pressed', isSel? 'true':'false');
      if(hintedColors.has(it)){
        const c = hintedColors.get(it);
        b.style.borderColor = c;
        b.style.outline = '2px solid ' + c;
        b.style.background = rgba(c, 0.12);
      }
      b.addEventListener('click', ()=> toggle(it), {passive:true});
      frag.appendChild(b);
    }

    gridEl.appendChild(frag);
    fitTiles();

    const done = PUZZLE && solved.length===PUZZLE.categories.length;
    submitEl.disabled = deselectEl.disabled = shuffleEl.disabled = hintEl.disabled = !!done || !PUZZLE;
  }

  function toggle(it){
    if(!remaining.has(it)) return;
    if(selected.has(it)) selected.delete(it);
    else { if(selected.size===4) selected.delete([...selected][0]); selected.add(it); }
    const nodes = gridEl.querySelectorAll('.tile');
    for(const n of nodes){
      const isSel = selected.has(n.textContent);
      n.classList.toggle('selected', isSel);
      n.setAttribute('aria-pressed', isSel ? 'true' : 'false');
    }
  }

  function countOverlap(arr, group){ const set=new Set(group); return arr.reduce((n,x)=> n+(set.has(x)?1:0),0); }

  function onSubmit(){
    if(!PUZZLE) return;
    if(selected.size!==4){ showToast('Select 4 tiles.','warn'); return; }
    const sel=[...selected];
    const catIdx=itemToCat.get(sel[0]);
    const allSame = sel.every(it=> itemToCat.get(it)===catIdx);
    if(allSame){
      const cat=PUZZLE.categories[catIdx];
      solved.push({name:cat.name, color:cat.color, items:cat.items.slice()});
      for(const it of sel) remaining.delete(it);
      selected.clear();
      showToast('Correct!','ok');
      if(solved.length===PUZZLE.categories.length){ showToast('You solved NeuroConnections!','ok'); }
      render();
    }else{
      const oneAway = PUZZLE.categories.some(cat=> countOverlap(sel, cat.items)===3);
      showToast(oneAway? 'One away!':'Nope. Try again.', oneAway? 'warn':'err');
    }
  }

  function onShuffle(){ order = shuffle(getUnsolvedOrder()); render(); }
  function onDeselect(){ selected.clear(); const tiles=gridEl.querySelectorAll('.tile'); tiles.forEach(t=>{ t.classList.remove('selected'); t.setAttribute('aria-pressed','false'); }); fitTiles(); }

  function onHint(){
    if(!PUZZLE) return;
    // Phase 1: reveal one random tile color from an unsolved group
    if(hintPhase === 'idle'){
      const idx = chooseUnsolvedGroupIndex();
      if(idx < 0){ showToast('No groups left to hint.','warn'); return; }
      const cat = PUZZLE.categories[idx];
      const candidates = cat.items.filter(it => remaining.has(it));
      if(!candidates.length){ showToast('No groups left to hint.','warn'); return; }
      const item = candidates[Math.floor(Math.random()*candidates.length)];
      hintedColors.set(item, cat.color);
      hintPhase = 'single'; hintGroupIdx = idx; hintedItem = item;
      showToast('Hint: one tile highlighted','warn');
      render();
      return;
    }
    // Phase 2: reveal the entire color and auto-solve that group
    if(hintPhase === 'single' && hintGroupIdx >= 0){
      const cat = PUZZLE.categories[hintGroupIdx];
      cat.items.forEach(it => hintedColors.set(it, cat.color));
      // Immediately move to solved (behaves like a correct submission)
      solved.push({name:cat.name, color:cat.color, items:cat.items.slice()});
      cat.items.forEach(it => remaining.delete(it));
      selected.clear();
      showToast('Hint solved: ' + cat.name, 'ok');
      clearHintState();
      render();
    }
  }

  submitEl.addEventListener('click', onSubmit);
  shuffleEl.addEventListener('click', onShuffle);
  deselectEl.addEventListener('click', onDeselect);
  hintEl.addEventListener('click', onHint);

  // Secret: press 'N' to advance the date offset and reload
  window.addEventListener('keydown', (e)=>{
    const k = (e.key||'').toLowerCase();
    if(k === 'n'){
      dayOffset += 1;
      if(PUZZLES.length){
        PUZZLE = selectPuzzleForCurrentOffset();
        initBoard();
        showToast(`Advanced date â†’ ${phoenixISODateFromOffset(dayOffset)}`, 'ok');
      }
    }
  }, {passive:true});

  // ================= Boot =================
  (async function boot(){
    try{
      const res = await fetch('puzzles.csv', {cache:'no-store'});
      if(!res.ok) throw new Error('HTTP '+res.status);
      const text = await res.text();
      const rows = parseCSV(text);
      PUZZLES = rowsToPuzzles(rows);
      if(!PUZZLES.length) throw new Error('No valid puzzles found');
      PUZZLE = selectPuzzleForCurrentOffset();
      initBoard();
    }catch(e){
      console.warn('Fetch failed, enabling local CSV uploader.', e);
      loaderEl.textContent = "Couldn't fetch puzzles.csv.\nâ€¢ Put index.html and puzzles.csv together and use a local server, or\nâ€¢ Upload the CSV below.";
      uploaderEl.classList.add('show');
      dateEl.textContent = `Puzzle date: ${phoenixISODateFromOffset(dayOffset)} (awaiting CSV)`;
    }
  })();

  // Local CSV uploader fallback
  fileInput.addEventListener('change', (ev)=>{
    const file = ev.target.files && ev.target.files[0];
    if(!file) return;
    const reader = new FileReader();
    reader.onload = ()=>{
      try{
        const text = String(reader.result||'');
        const rows = parseCSV(text);
        PUZZLES = rowsToPuzzles(rows);
        if(!PUZZLES.length) throw new Error('No valid puzzles in CSV');
        PUZZLE = selectPuzzleForCurrentOffset();
        uploaderEl.classList.remove('show');
        initBoard();
      }catch(err){ console.error(err); showToast('Invalid CSV format.','err'); }
    };
    reader.readAsText(file);
  });
  </script>
</body>
</html>
